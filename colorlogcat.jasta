#!/usr/bin/python

# script to highlight adb logcat output for console
# released apache2 by jeff sharkey

# modified by josh guilfoyle <jasta@devtcg.org> to use formatting closer to how
# it comes out of logcat.

import sys, re, StringIO
import fcntl, termios, struct

# unpack the current terminal width/height
#data = fcntl.ioctl(sys.stdout.fileno(), termios.TIOCGWINSZ, '1234')
#HEIGHT, WIDTH = struct.unpack('hh',data)

BLACK, RED, GREEN, YELLOW, BLUE, MAGENTA, CYAN, WHITE = range(8)

def format(fg=None, bg=None, bright=False, bold=False, dim=False, reset=False):
    codes = []
    if reset: codes.append("0")
    else:
        if not fg is None: codes.append("3%d" % (fg))
        if not bg is None:
            if not bright: codes.append("4%d" % (bg))
            else: codes.append("10%d" % (bg))
        if bold: codes.append("1")
        elif dim: codes.append("2")
        else: codes.append("22")
    return "\033[%sm" % (";".join(codes))


def indent_wrap(message, indent=0, width=80):
    wrap_area = width - indent
    messagebuf = StringIO.StringIO()
    current = 0
    while current < len(message):
        next = min(current + wrap_area, len(message))
        messagebuf.write(message[current:next])
        if next < len(message):
            messagebuf.write("\n%s" % (" " * indent))
        current = next
    return messagebuf.getvalue()


LAST_USED = [RED,GREEN,YELLOW,BLUE,MAGENTA,CYAN,WHITE]
KNOWN_TAGS = {
    "dalvikvm": BLACK,
    "Process": YELLOW,
    "ActivityManager": CYAN,
    "ActivityThread": CYAN,
}

def allocate_color(tag):
    # this will allocate a unique format for the given tag
    # since we dont have very many colors, we always keep track of the LRU
    if not tag in KNOWN_TAGS:
        KNOWN_TAGS[tag] = LAST_USED[0]
    color = KNOWN_TAGS[tag]
    if color in LAST_USED:
        LAST_USED.remove(color)
        LAST_USED.append(color)
    return color


RULES = {
    #re.compile(r"([\w\.@]+)=([\w\.@]+)"): r"%s\1%s=%s\2%s" % (format(fg=BLUE), format(fg=GREEN), format(fg=BLUE), format(reset=True)),
}

TAGTYPE_WIDTH = 1
TAG_WIDTH = 20
PROCESS_WIDTH = 8 # 8 or -1
HEADER_SIZE = TAGTYPE_WIDTH + 1 + TAG_WIDTH + 1 + PROCESS_WIDTH + 1 + 1

TAGTYPES = {
    "V": "",
    "D": format(fg=BLUE, bold=True),
    "I": "",
    "W": format(fg=YELLOW, bold=True),
    "E": format(fg=RED, bold=True),
}

retag = re.compile("^([A-Z])/([^\(]+)\(([^\)]+)\):(.*)$")

while True:
    try:
        line = sys.stdin.readline()
    except KeyboardInterrupt:
        break

    match = retag.match(line)
    if not match is None:
        tagtype, tag, owner, message = match.groups()
        linebuf = StringIO.StringIO()

#        # center process info
#        if PROCESS_WIDTH > 0:
#            owner = owner.strip().center(PROCESS_WIDTH)
#            linebuf.write("%s%s%s " % (format(fg=BLACK, bg=BLACK, bright=True), owner, format(reset=True)))
#
#        # right-align tag title and allocate color if needed
#        tag = tag.strip()
#        color = allocate_color(tag)
#        tag = tag[-TAG_WIDTH:].rjust(TAG_WIDTH)
#        linebuf.write("%s%s %s " % (format(fg=color, dim=False), tag, format(reset=True)))

        # write out tagtype colored edge
        if not tagtype in TAGTYPES: break
        linebuf.write("%s%s%s" % (TAGTYPES[tagtype], tagtype, format(reset=True)))

        color = allocate_color(tag)
        linebuf.write(" / %s%s%s" % (format(fg=color, bold=True), tag, format(reset=True)))

        linebuf.write(" (%s): " % owner)

#        # insert line wrapping as needed
#        message = indent_wrap(message.strip(), HEADER_SIZE, WIDTH)

        # format tag message using rules
        for matcher in RULES:
            replace = RULES[matcher]
            message = matcher.sub(replace, message)

        linebuf.write("%s%s%s" % (format(fg=color, bold=True), message, format(reset=True)))
        line = linebuf.getvalue()

    print line
    if len(line) == 0: break












